<script type="text/javascript" language="javascript">

window.onload = function(e) { 
	mainCurrencyAsFirst();
	populateDropDown(); 
	getRates();
};

var columnCurs = ['UAH','USD','USDT','USDC','EUR','PLN'];
var rowCurrs = ['BTC','ETH','LTC','BCH','USDC','USDT'];
var allCurrs = new Set(columnCurs.concat(rowCurrs));
var MainCur = 'USDT';
var Rates = new Map();
const Precision = 2;

// true means result rate will be (columnCur/MainCur) otherwise (MainCur/columnCur)
// Set to false for expensive main currency (like BTC)
const IsPriceReversed = false;
// true means row_column rate otherwise column_row
// Set to false for expensive main currency (like BTC)
const IsRawToColumnRate = true;

const PROVIDER = {
	EXMO: 'EXMO',
	WIREX: 'WIREX',
	BINANCE: 'BINANCE'
}

class BaseProvider 
{
	constructor() {
		this.separator = '';
	}

	toTicker(cur1,cur2) {
		return `${cur1}${this.separator}${cur2}`;
	}

	toRate(response,cur1,cur2) {
		var ticker = this.toTicker(cur1, cur2);
		var rate = this.pickRate(response, ticker);
		if (!rate)
			return;
		// Overriding provider ticker format
		rate.name = getTicker(cur1, cur2);
		rate.reverse = new Rate(getTicker(cur2, cur1), 1 / rate.bid, 1 / rate.ask, rate);
		return rate;
	}	

	// Override it for your provider
	pickRate(response,ticker) { return; }
}

class ExmoProvider extends BaseProvider {
	constructor() {
		super();
		this.name = PROVIDER.EXMO;
		this.tableId = 'table_exmo';
		this.separator = '_';
		this.url = 'https://api.exmo.com/v1/ticker/';
	}

	pickRate(response,ticker) {
		var rate = response[ticker];
		if (!rate)
			return;
		return new Rate(ticker, rate.sell_price, rate.buy_price);
	}
}

class WirexProvider extends BaseProvider {
	constructor() {
		super();
		this.name = PROVIDER.WIREX;
		this.tableId = 'table_wirex';
		this.separator = '/';
		this.url = 'https://api.wirexapp.com/public/ticker?format=json';
	}

	pickRate(response,ticker) {
		var rate = response.rates.find(x => x.ticker === ticker);
		if (!rate)
			return;
		return new Rate(ticker, rate.ask, rate.bid);
	}
}

class BinanceProvider extends BaseProvider {
	constructor() {
		super();
		this.name = PROVIDER.BINANCE;
		this.tableId = 'table_binance';
		this.separator = '';
		this.url = 'https://api.binance.com/api/v3/ticker/bookTicker';
	}

	pickRate(response,ticker) {
		var rate = response.find(x => x.symbol === ticker);
		if (!rate || rate.askPrice == 0)
			return;
		return new Rate(ticker, rate.askPrice, rate.bidPrice);
	}
}

const PROVIDERS = new Map([
	[PROVIDER.EXMO, new ExmoProvider() ],
	[PROVIDER.WIREX, new WirexProvider() ],
	[PROVIDER.BINANCE, new BinanceProvider() ]
]);

// What we will do with second currency of ticker  
const OPERATION_TYPE = {
	BUY: 'BUY',
	SELL: 'SELL'
}

function Rate(name,ask,bid,reverse = {}) {
	this.name = name;
	this.ask = parseFloat(ask);
	this.bid = parseFloat(bid);
	this.reverse = reverse;
}

async function getRates()
{
	// TODO: paralel
	await getProviderRates(PROVIDER.EXMO);
	populateRates(PROVIDER.EXMO);
	await getProviderRates(PROVIDER.WIREX);
	populateRates(PROVIDER.WIREX);
	await getProviderRates(PROVIDER.BINANCE);
	populateRates(PROVIDER.BINANCE);
	resizeTables();
}

async function getProviderRates(provider)
{
	var rates = new Map();
	Rates.set(provider, rates);

	var url = PROVIDERS.get(provider).url;
	var response = await fetch(url);
	for (let rowCur of allCurrs)
	{
		for (let columnCur of allCurrs)
		{
			if (rowCur !== columnCur)
			{
				var rate = getRate(rowCur, columnCur);
				if (rate)
					rates.set(rate.name, rate);
			}
		}
	}

	function getRate(cur1, cur2, findReverse = true) 
	{
		// TODO: using response makes function not pure
		var rate = PROVIDERS.get(provider).toRate(response,cur1,cur2);
		if (rate)
			return rate;
		else if (findReverse) 
			return getRate(cur2, cur1, false);
		return;
	}
}

function findRateToSell(cur1,cur2,PROVIDER)
{
	var rates = Rates.get(PROVIDER);
	return rates.get(getTicker(cur1, cur2)) 
		?? (rates.get(getTicker(cur2, cur1)))?.reverse;
}

function populateRates(provider)
{
	// Header
	var htmlText = "<tr><th></th>";
	for (let columnCur of columnCurs)
	{
		htmlText += "<th>" + columnCur + "</th>";
	}
	htmlText += "</tr>";

	// Rows
	for (let rowCur of rowCurrs)
	{
		htmlText += "<tr><th>" + rowCur + "</th>";
		for (let columnCur of columnCurs)
		{
			// For example UAH_BTC
			var firstRate = findRateToSell(MainCur, rowCur, provider);
			if (columnCur === MainCur)
			{
				var rateToShow = IsRawToColumnRate ? firstRate?.reverse : firstRate;
				htmlText += "<td>" + printValue(rateToShow?.ask);
			}
			else
			{
				// For example BTC_USD
				var secondRate = findRateToSell(rowCur, columnCur, provider);
				var rateToShow = IsRawToColumnRate ? secondRate : secondRate?.reverse;
				htmlText += "<td>" + printValue(rateToShow?.bid);
				htmlText += printPrice(getPrice(firstRate?.bid * secondRate?.bid));
			}

			htmlText += "</td>";
		}
		htmlText += "</tr>";
	}

	// Native
	htmlText += "<tr><th>Native</th>";
	for (let columnCur of columnCurs)
	{
		if (columnCur != MainCur)
		{
			var rate = findRateToSell(columnCur, MainCur, provider);
			htmlText += "<td>" + printValue(rate?.bid) + "</td>";
		}
		else
		{
			htmlText += "<td></td>";
		}
	}

	var tableId = PROVIDERS.get(provider).tableId;
	document.getElementById(tableId).innerHTML = htmlText;
}

function fetch(url) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('get', url, true);
        xhr.onload = function(e) {
        	resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function () {
        	resolve(undefined);
        	console.error("** An error occurred during the XMLHttpRequest");
        };
        xhr.send();
    });
}

function populateDropDown()
{
  	var select = document.getElementById('main_currency');
  	columnCurs.forEach((x, key) => { select[key] = new Option(x, x); });
}

// Make main currency column at first
function mainCurrencyAsFirst()
{
	//columnCurs = columnCurs.filter(item => item !== MainCur);
	//columnCurs.unshift(MainCur);
	var index = columnCurs.indexOf(MainCur);
	if (index !== 0)
		[columnCurs[0], columnCurs[index]] = [columnCurs[index], columnCurs[0]];
}

function dropDownChanged(value)
{
	MainCur = value;
	mainCurrencyAsFirst();
	populateRates(PROVIDER.EXMO);
	populateRates(PROVIDER.WIREX);
	populateRates(PROVIDER.BINANCE);
	resizeTables();
}

function resizeTables()
{
	// Resize columns width
	var tableIds = Array.from(PROVIDERS).map(x => x[1].tableId);
	var tables = tableIds.map(x => document.getElementById(x));
	columnCurs.forEach((x, index) => {
		var columns = tables.map(x => x.rows[0].cells[index + 1]);
		var maxWidth = Math.max(...columns.map(x => x.clientWidth));
		columns.forEach(x => x.width = maxWidth + 2);
	});
}

function getTicker(cur1,cur2)
{
	return `${cur1}_${cur2}`;
}

function getPrice(rate)
{
	return IsPriceReversed ? 1 / rate : rate;
}

function printPrice(rate)
{
	return rate ? ` (${rate.toFixed(Precision)})` : '';
}

function printValue(value, whenEmpty = '-')
{
	return value ? value.toFixed(Precision) : whenEmpty;
}
</script>


<html>
<title>Exmo API</title> 
<head>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<style>
		.element {
			margin: 7px;
		}
		#main_currency {
			max-width: 150px;
		}
	</style>
</head>
<div class="container-fluid">
	<select id="main_currency" class="custom-select element" onchange="dropDownChanged(this.value)"></select>

	<h3 class="element">Exmo</h3>
	<table id="table_exmo" style="table-layout:fixed" class="element" border='1'></table>
	<h3 class="element">Wirex</h3>
	<table id="table_wirex" class="element" border='1'></table>
	<h3 class="element">Binance</h3>
	<table id="table_binance" class="element" border='1'></table>
</div>
</html>
